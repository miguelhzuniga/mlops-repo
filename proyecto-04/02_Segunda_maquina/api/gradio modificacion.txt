# ‚úÖ Actualizaci√≥n: soporte para DecisionTreeRegressor y LightGBM
def get_shap_summary_plot():
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    plt.ioff()

    try:
        if current_model_name not in loaded_models:
            fig, ax = plt.subplots(figsize=(10, 6))
            ax.text(0.5, 0.5, "‚ùå No hay modelo cargado", ha='center', va='center', 
                   fontsize=16, transform=ax.transAxes,
                   bbox=dict(boxstyle="round,pad=0.5", facecolor="lightblue"))
            ax.axis('off')
            return fig

        import shap
        print("‚úÖ SHAP importado")

        model = loaded_models[current_model_name]
        print(f"üéØ Iniciando SHAP para: {current_model_name}")

        # Obtener nombres de caracter√≠sticas
        def get_feature_names_from_preprocessor():
            try:
                preprocessor = load_preprocessor()
                if hasattr(preprocessor, 'get_feature_names_out'):
                    return list(preprocessor.get_feature_names_out())
                elif hasattr(preprocessor, 'get_feature_names'):
                    return list(preprocessor.get_feature_names())
                else:
                    return get_feature_names_manual(preprocessor)
            except Exception as e:
                print(f"‚ö†Ô∏è Error obteniendo nombres del preprocesador: {e}")
                return None

        def get_feature_names_manual(preprocessor):
            try:
                feature_names = []
                if hasattr(preprocessor, 'transformers_'):
                    for name, transformer, features in preprocessor.transformers_:
                        if name == 'num':
                            feature_names.extend([f"num__{feat}" for feat in features])
                        elif name == 'cat':
                            if hasattr(transformer, 'categories_'):
                                for i, feature in enumerate(features):
                                    categories = transformer.categories_[i]
                                    for category in categories:
                                        feature_names.append(f"cat__{feature}__{category}")
                return feature_names
            except Exception as e:
                print(f"‚ö†Ô∏è Error en extracci√≥n manual: {e}")
                return None

        def create_feature_mapping(feature_names, shap_values):
            important_patterns = {
                'bed': 'Habitaciones',
                'bath': 'Ba√±os',
                'acre_lot': 'Terreno (acres)',
                'house_size': 'Tama√±o casa (sqft)',
                'prev_sold_year': 'A√±o venta anterior',
                'status__for_sale': 'Estado: En venta',
                'status__ready_to_build': 'Estado: Listo construir',
                'state__Connecticut': 'Estado: Connecticut',
                'state__New York': 'Estado: Nueva York',
                'city__East Windsor': 'Ciudad: East Windsor',
                'brokered_by': 'Agencia inmobiliaria'
            }

            feature_importance = np.abs(shap_values).mean(axis=0)
            top_indices = np.argsort(feature_importance)[-20:]

            mapped_names = []
            for idx in top_indices:
                original_name = feature_names[idx] if feature_names and idx < len(feature_names) else f"Feature_{idx}"
                descriptive_name = original_name
                for pattern, desc_name in important_patterns.items():
                    if pattern in original_name:
                        descriptive_name = desc_name
                        break
                if descriptive_name == original_name and feature_names:
                    if 'num__' in original_name:
                        descriptive_name = original_name.replace('num__', '').replace('_', ' ').title()
                    elif 'cat__' in original_name:
                        parts = original_name.replace('cat__', '').split('__')
                        descriptive_name = f"{parts[0].title()}: {parts[1]}" if len(parts) >= 2 else parts[0].title()
                mapped_names.append((idx, descriptive_name, feature_importance[idx]))
            mapped_names.sort(key=lambda x: x[2], reverse=True)
            return mapped_names

        # Crear datos de muestra
        shap_samples = pd.DataFrame({
            'bed': [2, 3, 4, 5, 2],
            'bath': [1, 2, 3, 3, 1],
            'acre_lot': [0.15, 0.25, 0.35, 0.45, 0.20],
            'house_size': [1000, 1500, 2000, 2500, 1200],
            'prev_sold_year': [2020, 2019, 2018, 2017, 2021]
        })

        full_samples = []
        for _, row in shap_samples.iterrows():
            full_record = {
                'bed': row['bed'], 'bath': row['bath'], 'acre_lot': row['acre_lot'],
                'house_size': row['house_size'], 'prev_sold_year': int(row['prev_sold_year']),
                'brokered_by': '101640.0', 'status': 'for_sale', 'street': '1758218.0',
                'city': 'East Windsor', 'state': 'Connecticut', 'zip_code': '6016.0',
                'prev_sold_date': f"{int(row['prev_sold_year'])}-01-01"
            }
            full_samples.append(full_record)

        full_df = pd.DataFrame(full_samples)
        X_processed = preprocess_input(full_df)
        if hasattr(X_processed, 'toarray'):
            X_processed = X_processed.toarray()
        print(f"‚úÖ Datos preprocesados: {X_processed.shape}")

        feature_names = get_feature_names_from_preprocessor()
        if feature_names:
            print(f"‚úÖ {len(feature_names)} nombres de caracter√≠sticas obtenidos")
        else:
            print("‚ö†Ô∏è No se pudieron obtener nombres, usando gen√©ricos")

        # SHAP explainer universal
        print("üöÄ Creando TreeExplainer universal...")
        explainer = shap.TreeExplainer(model)

        print("üöÄ Calculando SHAP values...")
        X_analysis = X_processed[:3]
        shap_values = explainer.shap_values(X_analysis)
        if isinstance(shap_values, list):
            shap_values = shap_values[0]

        print(f"‚úÖ SHAP values calculados: {shap_values.shape}")

        mapped_features = create_feature_mapping(feature_names, shap_values)
        top_features = mapped_features[:15]
        top_indices = [item[0] for item in top_features]
        top_names = [item[1] for item in top_features]

        fig, ax = plt.subplots(figsize=(12, 10))
        shap_values_top = shap_values[:, top_indices]
        X_analysis_top = X_analysis[:, top_indices]

        shap.summary_plot(
            shap_values_top,
            X_analysis_top,
            feature_names=top_names,
            show=False,
            max_display=15
        )
        plt.title(f"SHAP - Caracter√≠sticas M√°s Importantes\n{current_model_name} (Top 15 de {X_processed.shape[1]} caracter√≠sticas)", fontsize=14, pad=20)
        plt.tight_layout()

        print("‚úÖ SHAP con nombres descriptivos completado")
        return fig

    except Exception as e:
        fig, ax = plt.subplots(figsize=(10, 6))
        error_text = f"‚ùå Error en SHAP con nombres:\n\n{str(e)[:200]}...\n\nüîÑ Intentando m√©todo de backup..."
        ax.text(0.5, 0.5, error_text, ha='center', va='center', fontsize=10, 
               transform=ax.transAxes, bbox=dict(boxstyle="round,pad=0.5", facecolor="lightcoral"))
        ax.axis('off')
        print(f"‚ùå Error: {str(e)}")
        try:
            return get_shap_hybrid_method(loaded_models[current_model_name])
        except:
            return fig