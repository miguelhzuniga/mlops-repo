# üå≥ VERSI√ìN CON TREE EXPLAINER - Ultra r√°pido para LightGBM

def get_shap_summary_plot():
    """SHAP analysis usando TreeExplainer optimizado para LightGBM"""
    
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    plt.ioff()
    
    try:
        # ‚úÖ Verificaciones b√°sicas
        if current_model_name not in loaded_models:
            fig, ax = plt.subplots(figsize=(10, 6))
            ax.text(0.5, 0.5, "‚ùå No hay modelo cargado", ha='center', va='center', 
                   fontsize=16, transform=ax.transAxes,
                   bbox=dict(boxstyle="round,pad=0.5", facecolor="lightblue"))
            ax.axis('off')
            return fig
        
        try:
            import shap
            print("‚úÖ SHAP importado")
        except ImportError:
            fig, ax = plt.subplots(figsize=(10, 6))
            ax.text(0.5, 0.5, "‚ùå SHAP no disponible", ha='center', va='center', 
                   fontsize=16, transform=ax.transAxes)
            ax.axis('off')
            return fig
        
        model = loaded_models[current_model_name]
        print(f"üå≥ Iniciando TreeExplainer para: {current_model_name}")
        
        # üå≥ PASO CR√çTICO: Extraer el modelo LightGBM real del wrapper MLflow
        print("üîç Identificando tipo de modelo...")
        
        lightgbm_model = None
        try:
            # M√©todo 1: Si es un wrapper de MLflow
            if hasattr(model, '_model_impl'):
                if hasattr(model._model_impl, 'lgb_model'):
                    lightgbm_model = model._model_impl.lgb_model
                    print("‚úÖ Modelo LightGBM extra√≠do de MLflow wrapper (m√©todo 1)")
                elif hasattr(model._model_impl, '_model'):
                    lightgbm_model = model._model_impl._model
                    print("‚úÖ Modelo LightGBM extra√≠do de MLflow wrapper (m√©todo 2)")
            
            # M√©todo 2: Acceso directo a sklearn wrapper
            if lightgbm_model is None and hasattr(model, 'predict'):
                # Intentar crear datos de prueba para verificar si funciona con TreeExplainer
                test_data = [[3, 2, 0.25, 1500, 2020]]
                
                # Verificar si podemos usar TreeExplainer directamente
                try:
                    temp_explainer = shap.TreeExplainer(model)
                    lightgbm_model = model
                    print("‚úÖ Modelo compatible directamente con TreeExplainer")
                except Exception as e:
                    print(f"‚ö†Ô∏è TreeExplainer directo fall√≥: {e}")
            
            # M√©todo 3: Buscar en atributos del modelo
            if lightgbm_model is None:
                for attr in ['_model', 'model_', 'booster_', '_booster']:
                    if hasattr(model, attr):
                        potential_model = getattr(model, attr)
                        try:
                            temp_explainer = shap.TreeExplainer(potential_model)
                            lightgbm_model = potential_model
                            print(f"‚úÖ Modelo LightGBM encontrado en atributo: {attr}")
                            break
                        except:
                            continue
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error extrayendo modelo LightGBM: {e}")
        
        # Si no encontramos el modelo LightGBM, usar m√©todo alternativo
        if lightgbm_model is None:
            print("‚ö†Ô∏è No se pudo extraer modelo LightGBM, usando m√©todo h√≠brido...")
            return get_shap_hybrid_method(model)
        
        print(f"üå≥ Usando TreeExplainer con modelo tipo: {type(lightgbm_model)}")
        
        # üå≥ Preparar datos de muestra para TreeExplainer
        # TreeExplainer necesita datos en formato que entienda el modelo
        shap_samples = pd.DataFrame({
            'bed': [2, 3, 4, 5, 2],
            'bath': [1, 2, 3, 3, 1], 
            'acre_lot': [0.15, 0.25, 0.35, 0.45, 0.20],
            'house_size': [1000, 1500, 2000, 2500, 1200],
            'prev_sold_year': [2020, 2019, 2018, 2017, 2021]
        })
        
        print(f"üå≥ Dataset preparado: {shap_samples.shape}")
        
        # üå≥ IMPORTANTE: Necesitamos preparar los datos en el formato que espera el modelo
        # TreeExplainer trabaja directamente con el modelo, as√≠ que necesitamos datos preprocesados
        
        # Crear datos completos para el preprocesamiento
        full_samples = []
        for _, row in shap_samples.iterrows():
            full_record = {
                'bed': row['bed'],
                'bath': row['bath'],
                'acre_lot': row['acre_lot'],
                'house_size': row['house_size'],
                'prev_sold_year': int(row['prev_sold_year']),
                # Valores fijos para categ√≥ricas
                'brokered_by': '101640.0',
                'status': 'for_sale',
                'street': '1758218.0', 
                'city': 'East Windsor',
                'state': 'Connecticut',
                'zip_code': '6016.0',
                'prev_sold_date': f"{int(row['prev_sold_year'])}-01-01"
            }
            full_samples.append(full_record)
        
        # Preprocesar todos los datos
        full_df = pd.DataFrame(full_samples)
        X_processed = preprocess_input(full_df)
        
        print(f"üå≥ Datos preprocesados: {X_processed.shape}")
        
        # Verificar si es sparse matrix y convertir si es necesario
        if hasattr(X_processed, 'toarray'):
            X_processed = X_processed.toarray()
            print("üå≥ Convertido de sparse a dense matrix")
        
        # üå≥ CREAR TREE EXPLAINER - ¬°S√∫per r√°pido!
        print("üå≥ Creando TreeExplainer...")
        import time
        start_time = time.time()
        
        try:
            explainer = shap.TreeExplainer(lightgbm_model)
            explainer_time = time.time() - start_time
            print(f"‚úÖ TreeExplainer creado en {explainer_time:.2f} segundos")
        except Exception as e:
            print(f"‚ùå Error creando TreeExplainer: {e}")
            # Fallback al m√©todo h√≠brido
            return get_shap_hybrid_method(model)
        
        # üå≥ CALCULAR SHAP VALUES - Deber√≠a ser s√∫per r√°pido ahora
        print("üå≥ Calculando SHAP values con TreeExplainer...")
        calc_start = time.time()
        
        # Usar solo las primeras 3 muestras para velocidad
        X_analysis = X_processed[:3]
        
        try:
            shap_values = explainer.shap_values(X_analysis)
            
            # Verificar si shap_values es una lista (multi-output) o array
            if isinstance(shap_values, list):
                shap_values = shap_values[0]  # Usar el primer output para regresi√≥n
            
            calc_time = time.time() - calc_start
            print(f"‚úÖ SHAP values calculados en {calc_time:.2f} segundos: {shap_values.shape}")
            
        except Exception as e:
            print(f"‚ùå Error calculando SHAP values: {e}")
            return get_shap_hybrid_method(model)
        
        # üå≥ CREAR VISUALIZACI√ìN
        fig, ax = plt.subplots(figsize=(12, 8))
        
        # Para TreeExplainer, necesitamos usar el formato correcto
        try:
            # Intentar obtener nombres de caracter√≠sticas si est√°n disponibles
            if X_processed.shape[1] <= 20:
                # Si tenemos pocas caracter√≠sticas, usar nombres descriptivos
                feature_names = [f"Feature_{i}" for i in range(X_processed.shape[1])]
            else:
                # Si tenemos muchas, usar las m√°s importantes
                feature_importance = np.abs(shap_values).mean(axis=0)
                top_indices = np.argsort(feature_importance)[-10:]  # Top 10
                shap_values_subset = shap_values[:, top_indices]
                X_subset = X_analysis[:, top_indices]
                feature_names = [f"Feature_{i}" for i in top_indices]
                
                # Usar subset para el plot
                shap.summary_plot(
                    shap_values_subset,
                    X_subset,
                    feature_names=feature_names,
                    show=False,
                    max_display=10
                )
            
            if X_processed.shape[1] <= 20:
                shap.summary_plot(
                    shap_values,
                    X_analysis,
                    feature_names=feature_names,
                    show=False,
                    max_display=min(15, X_processed.shape[1])
                )
            
        except Exception as plot_error:
            print(f"‚ö†Ô∏è Error en summary_plot: {plot_error}")
            # Plot manual simple
            feature_importance = np.abs(shap_values).mean(axis=0)
            top_10_idx = np.argsort(feature_importance)[-10:]
            
            plt.barh(range(len(top_10_idx)), feature_importance[top_10_idx])
            plt.yticks(range(len(top_10_idx)), [f"Feature_{i}" for i in top_10_idx])
            plt.xlabel("Importancia promedio |SHAP|")
        
        total_time = time.time() - start_time
        plt.title(f"TreeExplainer SHAP - {current_model_name}\n‚ö° Calculado en {total_time:.1f}s", 
                 fontsize=14)
        plt.tight_layout()
        
        print(f"‚úÖ TreeExplainer completado en {total_time:.1f}s total")
        return fig
        
    except Exception as e:
        fig, ax = plt.subplots(figsize=(10, 6))
        
        error_text = f"‚ùå Error TreeExplainer:\n\n{str(e)[:300]}...\n\n"
        error_text += "üîß Intentando m√©todo h√≠brido como fallback..."
        
        ax.text(0.5, 0.5, error_text, ha='center', va='center', fontsize=10, 
               transform=ax.transAxes,
               bbox=dict(boxstyle="round,pad=0.5", facecolor="lightcoral"))
        ax.axis('off')
        plt.title("TreeExplainer - Fallback", fontsize=14)
        
        print(f"‚ùå TreeExplainer error: {str(e)}")
        
        # Intentar m√©todo h√≠brido como backup
        try:
            return get_shap_hybrid_method(loaded_models[current_model_name])
        except:
            return fig

# üîÑ M√âTODO H√çBRIDO DE BACKUP
def get_shap_hybrid_method(model):
    """M√©todo h√≠brido r√°pido si TreeExplainer falla"""
    
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    
    print("üîÑ Usando m√©todo h√≠brido de backup...")
    
    try:
        # An√°lisis de importancia mediante permutaci√≥n r√°pida
        base_data = {
            'bed': 3, 'bath': 2, 'acre_lot': 0.25, 'house_size': 1500, 'prev_sold_year': 2020,
            'brokered_by': '101640.0', 'status': 'for_sale', 'street': '1758218.0',
            'city': 'East Windsor', 'state': 'Connecticut', 'zip_code': '6016.0',
            'prev_sold_date': '2020-01-01'
        }
        
        # Predicci√≥n base
        base_df = pd.DataFrame([base_data])
        base_processed = preprocess_input(base_df)
        base_price = model.predict(base_processed)[0]
        
        # Medir impacto de cada caracter√≠stica num√©rica
        feature_impacts = {}
        
        variations = {
            'Habitaciones (+1)': {'bed': 4},
            'Ba√±os (+1)': {'bath': 3},
            'Terreno (+0.1 acres)': {'acre_lot': 0.35},
            'Tama√±o (+500 sqft)': {'house_size': 2000},
            'A√±o m√°s reciente': {'prev_sold_year': 2023}
        }
        
        for feature_name, change in variations.items():
            mod_data = base_data.copy()
            mod_data.update(change)
            mod_df = pd.DataFrame([mod_data])
            mod_processed = preprocess_input(mod_df)
            impact = model.predict(mod_processed)[0] - base_price
            feature_impacts[feature_name] = impact
        
        # Crear visualizaci√≥n
        fig, ax = plt.subplots(figsize=(10, 6))
        
        features = list(feature_impacts.keys())
        impacts = list(feature_impacts.values())
        colors = ['green' if x > 0 else 'red' for x in impacts]
        
        bars = ax.barh(features, impacts, color=colors, alpha=0.7)
        ax.axvline(x=0, color='black', linestyle='-', alpha=0.5)
        ax.set_xlabel('Impacto en precio (USD)')
        ax.set_title(f'An√°lisis de Importancia H√≠brido - {current_model_name}\n(Baseline: ${base_price:,.0f})')
        
        # Valores en barras
        for bar, impact in zip(bars, impacts):
            width = bar.get_width()
            ax.text(width + (max(impacts) * 0.01), bar.get_y() + bar.get_height()/2, 
                   f'${impact:,.0f}', ha='left', va='center', fontweight='bold')
        
        plt.tight_layout()
        print("‚úÖ M√©todo h√≠brido completado")
        return fig
        
    except Exception as e:
        fig, ax = plt.subplots(figsize=(8, 4))
        ax.text(0.5, 0.5, f"Error en m√©todo h√≠brido: {str(e)[:100]}...", 
               ha='center', va='center')
        ax.axis('off')
        return fig