
def get_shap_summary_plot():
    """SHAP analysis ultra-optimizado para velocidad"""
    
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    plt.ioff()
    
    try:
        # ‚úÖ Verificaciones b√°sicas
        if current_model_name not in loaded_models:
            fig, ax = plt.subplots(figsize=(10, 6))
            ax.text(0.5, 0.5, "‚ùå No hay modelo cargado", ha='center', va='center', 
                   fontsize=16, transform=ax.transAxes,
                   bbox=dict(boxstyle="round,pad=0.5", facecolor="lightblue"))
            ax.axis('off')
            return fig
        
        try:
            import shap
            print("‚úÖ SHAP importado")
        except ImportError:
            fig, ax = plt.subplots(figsize=(10, 6))
            ax.text(0.5, 0.5, "‚ùå SHAP no disponible", ha='center', va='center', 
                   fontsize=16, transform=ax.transAxes)
            ax.axis('off')
            return fig
        
        model = loaded_models[current_model_name]
        print(f"üöÄ Iniciando SHAP ultra-r√°pido para: {current_model_name}")
        
        # üöÄ OPTIMIZACI√ìN 1: Dataset M√çNIMO (solo 3 muestras)
        shap_samples = pd.DataFrame({
            'bed': [2, 3, 4],          # Solo 3 valores
            'bath': [1, 2, 3], 
            'acre_lot': [0.2, 0.3, 0.4],
            'house_size': [1200, 1500, 2000],
            'prev_sold_year': [2020, 2019, 2018]
        })
        
        print(f"üöÄ Dataset m√≠nimo: {shap_samples.shape}")
        
        # üöÄ OPTIMIZACI√ìN 2: Funci√≥n wrapper ultra-simple
        def fast_predict(X_numeric):
            """Predicci√≥n optimizada para velocidad"""
            batch_predictions = []
            
            # Procesar en batch para eficiencia
            records = []
            for i in range(X_numeric.shape[0]):
                records.append({
                    'bed': int(X_numeric[i, 0]),
                    'bath': int(X_numeric[i, 1]),
                    'acre_lot': float(X_numeric[i, 2]), 
                    'house_size': int(X_numeric[i, 3]),
                    'prev_sold_year': int(X_numeric[i, 4]),
                    # Valores fijos para velocidad
                    'brokered_by': '101640.0',
                    'status': 'for_sale', 
                    'street': '1758218.0',
                    'city': 'East Windsor',
                    'state': 'Connecticut',
                    'zip_code': '6016.0',
                    'prev_sold_date': '2020-01-01'  # Fijo para velocidad
                })
            
            # Procesar todo el batch de una vez
            df_batch = pd.DataFrame(records)
            processed_batch = preprocess_input(df_batch)
            predictions = model.predict(processed_batch)
            
            return predictions
        
        # üöÄ OPTIMIZACI√ìN 3: Background ULTRA-M√çNIMO (solo 1 muestra)
        X_numeric = shap_samples[['bed', 'bath', 'acre_lot', 'house_size', 'prev_sold_year']].values
        background = X_numeric[:1]  # Solo 1 muestra de background
        
        print("üöÄ Creando explainer con background m√≠nimo...")
        
        # üöÄ OPTIMIZACI√ìN 4: Usar TreeExplainer si es LightGBM (m√°s r√°pido)
        try:
            # Intentar acceder al modelo original de LightGBM
            if hasattr(model, '_model_impl') or hasattr(model, 'predict'):
                # Para modelos MLflow, intentar TreeExplainer que es m√°s r√°pido
                explainer = shap.Explainer(fast_predict, background, max_evals=50)  # Limitar evaluaciones
            else:
                explainer = shap.Explainer(fast_predict, background)
        except:
            explainer = shap.Explainer(fast_predict, background)
        
        # üöÄ OPTIMIZACI√ìN 5: Analizar solo 2 muestras
        X_analysis = X_numeric[:2]  # Solo 2 muestras
        
        print("üöÄ Calculando SHAP values (optimizado)...")
        
        # üöÄ OPTIMIZACI√ìN 6: Agregar timeout y par√°metros de velocidad
        import time
        start_time = time.time()
        
        try:
            # Usar par√°metros para acelerar el c√°lculo
            shap_values = explainer(X_analysis, max_evals=100, silent=True)
        except TypeError:
            # Si no soporta par√°metros adicionales
            shap_values = explainer(X_analysis)
        
        calc_time = time.time() - start_time
        print(f"‚úÖ SHAP calculado en {calc_time:.1f} segundos: {shap_values.values.shape}")
        
        # üöÄ CREAR PLOT R√ÅPIDO
        fig, ax = plt.subplots(figsize=(10, 6))
        
        feature_names = ['Habitaciones', 'Ba√±os', 'Terreno', 'Tama√±o casa', 'A√±o venta']
        
        # Plot simplificado para velocidad
        shap.summary_plot(
            shap_values.values, 
            X_analysis,
            feature_names=feature_names,
            show=False,
            max_display=5,
            plot_size=(10, 6)
        )
        
        plt.title(f"SHAP R√°pido - {current_model_name}\n(An√°lisis de {X_analysis.shape[0]} muestras en {calc_time:.1f}s)", 
                 fontsize=12)
        plt.tight_layout()
        
        print(f"‚úÖ Plot completado en {time.time() - start_time:.1f}s total")
        return fig
        
    except Exception as e:
        fig, ax = plt.subplots(figsize=(10, 6))
        
        error_text = f"‚ùå Error SHAP:\n\n{str(e)[:200]}..."
        if "timeout" in str(e).lower() or "slow" in str(e).lower():
            error_text += "\n\nüöÄ El modelo es muy complejo para SHAP.\nIntenta la versi√≥n simplificada."
        
        ax.text(0.5, 0.5, error_text, ha='center', va='center', fontsize=10, 
               transform=ax.transAxes,
               bbox=dict(boxstyle="round,pad=0.5", facecolor="lightcoral"))
        ax.axis('off')
        plt.title("SHAP - Error de velocidad", fontsize=14)
        
        print(f"‚ùå Error SHAP: {str(e)}")
        return fig
